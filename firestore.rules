rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    /****************************************
     * Helper Functions
     ****************************************/
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isManager() {
      // Try to use custom claim first (if available), fall back to Firestore document
      return isSignedIn() && (
        (('isManager' in request.auth.token) && request.auth.token.isManager == true)  // Custom claim (preferred)
        ||
        (
          exists(/databases/$(database)/documents/users/$(request.auth.uid))
          && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isManager == true
        )  // Firestore document (fallback)
      );
    }

    function isBool(v) {
      return v is bool;
    }

    /****************************************
     * Users Collection
     ****************************************/
    match /users/{userId} {

      // CREATE:
      // User can create their own profile but cannot assign themselves manager.
      // We enforce allowed keys and ensure isManager is false (or omitted).
      allow create: if isOwner(userId)
        && (
          // Either isManager is omitted OR explicitly false
          !('isManager' in request.resource.data)
          || request.resource.data.isManager == false
        )
        // Allowed keys - only displayName, email, and isManager permitted
        // Use difference check: incoming keys must be subset of allowed keys
        && request.resource.data.keys().hasAll(['displayName', 'email'])
        && request.resource.data.keys().hasOnly(['displayName', 'email', 'isManager'])
        // Email must match auth token (ensures integrity)
        && request.resource.data.email == request.auth.token.email
        // If provided, isManager must be boolean
        && (!('isManager' in request.resource.data) || isBool(request.resource.data.isManager));

      // READ: User can read self; managers can read anyone.
      allow read: if isOwner(userId);
      allow read: if isManager();

      // UPDATE:
      // - Manager can update other users (including changing isManager).
      // - User updating self cannot change isManager.
      // - Email is immutable; restrict key set to existing keys to avoid schema drift.
      allow update: if (
          (isManager() && !isOwner(userId))  // Manager editing another user
          ||
          (
            isOwner(userId) 
            && (
              // isManager not in update, or it matches existing value
              !('isManager' in request.resource.data)
              || (
                ('isManager' in resource.data) 
                && ('isManager' in request.resource.data)
                && request.resource.data.isManager == resource.data.isManager
              )
            )
          ) // Self without role change
        )
        // Keep email immutable
        && request.resource.data.email == resource.data.email
        // Prevent adding arbitrary new keys (exact same set as before)
        && request.resource.data.keys().hasOnly(resource.data.keys())
        // Role must stay a boolean if present
        && (!('isManager' in resource.data) || isBool(resource.data.isManager));

      // DELETE: Blocked from client.
      allow delete: if false;
    }

    /****************************************
     * Orders Collection
     ****************************************/
    match /orders/{orderId} {

      // Helper: current order owner
      function isOrderOwner() {
        return isSignedIn() 
          && resource != null 
          && ('createdByUid' in resource.data) 
          && resource.data.createdByUid == request.auth.uid;
      }

      // CREATE:
      // Authenticated user can create an order but must set ownership fields correctly.
      // Enforce required fields and simple schema constraints.
      allow create: if isSignedIn()
        && request.resource.data.keys().hasAll(['createdByUid', 'createdByEmail', 'createdAt'])
        // Ownership integrity
        && request.resource.data.createdByUid == request.auth.uid
        && request.resource.data.createdByEmail == request.auth.token.email
        // Basic status constraint (adjust as needed)
        && request.resource.data.status in ['Factory Order', 'Locate', 'Dealer Exchange', 'Received', 'Delivered'];

      // READ:
      // Managers can read any order; non-managers only their own.
      // Split into two rules to avoid circular dependency with get() in isManager()
      allow read: if isOrderOwner();
      allow read: if isManager();

      // UPDATE:
      // - Managers can update any order.
      // - Owners can update limited mutable fields (e.g. status, notes) without changing ownership.
      // Split into two rules to avoid circular dependency with get() in isManager()
      allow update: if isManager();
      allow update: if isOrderOwner()
        // Ownership must remain unchanged
        && request.resource.data.createdByUid == resource.data.createdByUid
        && request.resource.data.createdByEmail == resource.data.createdByEmail
        // Restrict which keys owner may touch (cannot add/remove ownership fields or other protected fields)
        && request.resource.data.keys().hasOnly(resource.data.keys())
        // Optional: owners can only change these fields
        && request.resource.data.status in ['Factory Order', 'Locate', 'Dealer Exchange', 'Received', 'Delivered'];

      // DELETE: Managers only (or disallow entirely if you prefer soft deletes).
      allow delete: if isManager();
    }
  }
}
