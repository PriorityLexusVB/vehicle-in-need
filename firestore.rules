rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    /****************************************
     * Helper Functions
     ****************************************/
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // Check if user has manager status via custom claims (preferred)
    function hasManagerClaim() {
      return isSignedIn() 
        && ('isManager' in request.auth.token) 
        && request.auth.token.isManager == true;
    }

    // Check if user has manager status via Firestore document (fallback)
    // Note: This incurs an extra Firestore read but ensures managers work even
    // without custom claims being set. For best performance, run the 
    // set-manager-custom-claims.mjs script to sync custom claims.
    // When both custom claims and Firestore document exist, custom claims
    // are checked first (hasManagerClaim) as they're more performant.
    function hasManagerInFirestore() {
      return isSignedIn()
        && exists(/databases/$(database)/documents/users/$(request.auth.uid))
        && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isManager == true;
    }

    // Combined manager check: custom claims OR Firestore document
    // Custom claims are checked first as they're more performant
    function isManager() {
      return hasManagerClaim() || hasManagerInFirestore();
    }

    function isBool(v) {
      return v is bool;
    }

    /****************************************
     * Users Collection
     ****************************************/
    match /users/{userId} {

      // CREATE:
      // User can create their own profile but cannot assign themselves manager.
      // We enforce allowed keys and ensure isManager is false (or omitted).
      allow create: if isOwner(userId)
        && (
          // Either isManager is omitted OR explicitly false
          !('isManager' in request.resource.data)
          || request.resource.data.isManager == false
        )
        // Allowed keys - uid (optional), displayName (required), email (required), isManager (optional), isActive (optional)
        // Use difference check: incoming keys must be subset of allowed keys
        && request.resource.data.keys().hasAll(['displayName', 'email'])
        && request.resource.data.keys().hasOnly(['uid', 'displayName', 'email', 'isManager', 'isActive'])
        // Email must match auth token (ensures integrity)
        && request.resource.data.email == request.auth.token.email
        // If uid is provided, it must match the document path userId
        && (!('uid' in request.resource.data) || request.resource.data.uid == userId)
        // If provided, isManager must be boolean
        && (!('isManager' in request.resource.data) || isBool(request.resource.data.isManager))
        // If provided, isActive must be boolean
        && (!('isActive' in request.resource.data) || isBool(request.resource.data.isActive));

      // READ: User can read self; managers can read anyone.
      // Manager check uses both custom claims and Firestore document fallback.
      allow read: if isOwner(userId) || isManager();

      // UPDATE:
      // - Manager can update other users (including changing isManager, isActive, disabledAt, disabledBy).
      // - User updating self cannot change isManager, isActive, disabledAt, or disabledBy.
      // - Email is immutable.
      // - Manager updates can add new fields (for isActive, disabledAt, disabledBy)
      // - User self-updates cannot add arbitrary new keys.
      allow update: if (
          (isManager() && !isOwner(userId))  // Manager editing another user
          ||
          (
            isOwner(userId) 
            && (
              // isManager not in update, or it matches existing value
              !('isManager' in request.resource.data)
              || (
                ('isManager' in resource.data) 
                && ('isManager' in request.resource.data)
                && request.resource.data.isManager == resource.data.isManager
              )
            )
            && (
              // isActive not in update, or it matches existing value
              !('isActive' in request.resource.data)
              || (
                ('isActive' in resource.data) 
                && ('isActive' in request.resource.data)
                && request.resource.data.isActive == resource.data.isActive
              )
            )
            // Self cannot add disabledAt if it doesn't exist (prevent creating new disabled fields)
            && (!('disabledAt' in request.resource.data) || ('disabledAt' in resource.data))
            && (!('disabledBy' in request.resource.data) || ('disabledBy' in resource.data))
            // Self cannot add new keys
            && request.resource.data.keys().hasOnly(resource.data.keys())
          ) // Self without role/active change
        )
        // Keep email immutable
        && request.resource.data.email == resource.data.email
        // If isManager is being set in the update, ensure it's a boolean
        && (!('isManager' in request.resource.data) || isBool(request.resource.data.isManager))
        // If isActive is being set in the update, ensure it's a boolean
        && (!('isActive' in request.resource.data) || isBool(request.resource.data.isActive));

      // DELETE: Blocked from client.
      allow delete: if false;
    }

    /****************************************
     * Admin Audit Logs Collection
     * - Only server-side (Admin SDK) can write
     * - Managers can read for review
     * - No client writes allowed
     ****************************************/
    match /adminAuditLogs/{logId} {
      // READ: Only managers can read audit logs
      allow read: if isManager();
      
      // WRITE: No client writes - only server-side Admin SDK can write
      allow create, update, delete: if false;
    }

    /****************************************
     * Orders Collection
     ****************************************/
    match /orders/{orderId} {

      // Helper: current order owner
      function isOrderOwner() {
        return isSignedIn() 
          && resource != null 
          && ('createdByUid' in resource.data) 
          && resource.data.createdByUid == request.auth.uid;
      }

      // CREATE:
      // Authenticated user can create an order but must set ownership fields correctly.
      // Enforce required fields and simple schema constraints.
      allow create: if isSignedIn()
        && request.resource.data.keys().hasAll(['createdByUid', 'createdByEmail', 'createdAt'])
        // Ownership integrity
        && request.resource.data.createdByUid == request.auth.uid
        && request.resource.data.createdByEmail == request.auth.token.email
        // Basic status constraint (adjust as needed)
        && request.resource.data.status in ['Factory Order', 'Locate', 'Dealer Exchange', 'Received', 'Delivered'];

      // READ:
      // Owners can read their own orders.
      // Managers can read any order (via custom claims or Firestore document).
      allow read: if isOrderOwner() || isManager();

      // UPDATE:
      // - Managers can update any order (via custom claims or Firestore document).
      // - Owners can update limited mutable fields (e.g. status, notes) without changing ownership.
      allow update: if isManager();
      allow update: if isOrderOwner()
        // Ownership must remain unchanged
        && ('createdByUid' in request.resource.data)
        && request.resource.data.createdByUid == resource.data.createdByUid
        && ('createdByEmail' in request.resource.data)
        && request.resource.data.createdByEmail == resource.data.createdByEmail
        // Restrict which keys owner may touch (cannot add/remove ownership fields or other protected fields)
        && request.resource.data.keys().hasOnly(resource.data.keys())
        // Optional: owners can only change these fields
        && request.resource.data.status in ['Factory Order', 'Locate', 'Dealer Exchange', 'Received', 'Delivered'];

      // DELETE: Managers only (via custom claims or Firestore document).
      allow delete: if isManager();
    }
  }
}
